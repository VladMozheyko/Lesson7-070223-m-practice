/*
Задача
1) Сделать массив для хранения элементов
2) Сделать указатель на последний добавленный элемент массива
3) Сделать основные операции для стека: push - добавление, pop- удаление и возврат элемент в точку вызова,
peek - просто показывает вершину стека, но не удаляет ее
4*) Показать что такое переполнение стека и реализовать его динамическое расширение
5) Сделать вспомогательные методы для трассировки стека.
 */
public class Stack {
    //TODO Реализовать стек через очередь. Определить преимущества и недостатки каждого из подходов
    //TODO Реализовать стирание памяти при извлечении элемента
    private Object[] arr = new Object[5];     // Массив, в котором будут хранится значения стека
    private int cursor = 0;                   // Указатель на вершину стека


    /**
     * Метод для добавления элемента в стек
      * @param element добавляемый элемент
     */
    public void push(Object element){
        if(cursor == arr.length){          // Если память полностью заполнена, выделяем новую
            System.out.println("Произошло выделение дополнительной памяти");
            Object[] temp = arr;           // Копируем старую память
            arr = new Object[2*arr.length]; // Выделяем новую память. В 2 раза больше предыдущей
            copy(temp);                     // Копируем старые массив в новый
        }
        arr[cursor] = element;              // Добавляем элемент в вершину стека
        cursor++;                           // Смещаем вершину стека
    }

    /**
     * Метод для копирования элементов массива, при его расширении. Метод приватный, потому что нам он не понадобится за
     * пределами класса
     * @param temp старый массив
     */
    private void copy(Object[] temp) {
        for (int i = 0; i < cursor; i++){   // Просто перебираем старый массив и записываем его значение в новый массив
            arr[i] = temp[i];
        }
    }


    /**
     * Метод для удаления и возвращения вершины стека
     * @return - последний элемент в стеке
     */
    public Object pop(){
        if(!isEmpty()) {
            cursor--;                          // Указатель теперь указывает на последний элемент, он считается удаленным
            return arr[cursor];                // Возвращаем последний элемент в стеке(вершину)
        }
        // TODO подумать как решить задачу с использованием исключений
       return "\nСтек пуст. Удаление невозможно"; // Злоупотребляем Object и возвращаем строку
    }

    /**
     * Метод для возвращения последнего элемента стека
     * @return вершина стека
     */
    public Object peek(){
        if(!isEmpty()) {
            return arr[cursor - 1];             // Возвращаем последний элемент стека
        }
        return "\nСтек пуст. Удаление невозможно"; // Злоупотребляем Object и возвращаем строку
    }

    /**
     * Метод для проверки на пустоту стека
     * @return пустой ли стек
     */
    public boolean isEmpty(){
        if(cursor == 0){                  // Если стек пуст, возвращаем true
            return true;
        }
        return false;
    }

    /**
     * Метод для отображения памяти, выделенной для стека
     */
    public void display(){
        System.out.println("Выделенная память: ");   // Выводим массив, в котором хранится стек
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    /**
     * Метод для отображения стека - трассировки стека
     */
    public void trace(){
        System.out.println("Стек: ");
        for (int i = 0; i < cursor; i++) {           // Выводим стек
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

}
